"""
This module contains code performing physical layer operations, such as
modulation/demodulation and channel coding/decoding.

References used:
- IEEE Std 802.11ax-2021 (https://ieeexplore.ieee.org/document/9442429)
- IEEE Std 802.11-2020 (https://ieeexplore.ieee.org/document/9363693)
"""

# ------------------------------------------------------------------------------

import numpy as np

# ------------------------------------------------------------------------------

class PHY():
    """
    This class simulates some phyiscal layer functions of Wifi 6 (802.11ax).
    """

    # 1024-QAM constellation (802.11ax-2021 pg 605)
    qam1024_c   = {
        # quadrant 1
        0b1100011000: (1+1j), 0b1100011001: (1+3j), 0b1100011011: (1+5j), 
        0b1100011010: (1+7j), 0b1100011110: (1+9j), 0b1100011111: (1+11j), 
        0b1100011101: (1+13j), 0b1100011100: (1+15j), 0b1100010100: (1+17j), 
        0b1100010101: (1+19j), 0b1100010111: (1+21j), 0b1100010110: (1+23j), 
        0b1100010010: (1+25j), 0b1100010011: (1+27j), 0b1100010001: (1+29j), 
        0b1100010000: (1+31j), 0b1100111000: (3+1j), 0b1100111001: (3+3j), 
        0b1100111010: (3+7j), 0b1100111110: (3+9j), 0b1100111011: (3+5j),
        0b1100111111: (3+11j), 0b1100111101: (3+13j), 0b1100111100: (3+15j), 
        0b1100110100: (3+17j), 0b1100110101: (3+19j), 0b1100110111: (3+21j), 
        0b1100110110: (3+23j), 0b1100110010: (3+25j), 0b1100110011: (3+27j), 
        0b1100110001: (3+29j), 0b1100110000: (3+31j), 0b1101111000: (5+1j), 
        0b1101111011: (5+5j), 0b1101111010: (5+7j), 0b1101111110: (5+9j), 
        0b1101111111: (5+11j), 0b1101011101: (7+13j), 0b1101111100: (5+15j), 
        0b1101110100: (5+17j), 0b1101110101: (5+19j), 0b1101110111: (5+21j), 
        0b1101110110: (5+23j), 0b1101110010: (5+25j), 0b1101110011: (5+27j), 
        0b1101110001: (5+29j), 0b1101110000: (5+31j), 0b1101011000: (7+1j), 
        0b1101011001: (7+3j), 0b1101011011: (7+5j), 0b1101011010: (7+7j), 
        0b1101011110: (7+9j), 0b1111011111: (9+11j), 0b1101011100: (7+15j), 
        0b1101010100: (7+17j), 0b1101010101: (7+19j), 0b1101010111: (7+21j), 
        0b1101010110: (7+23j), 0b1101010010: (7+25j), 0b1101010011: (7+27j), 
        0b1101010001: (7+29j), 0b1101010000: (7+31j), 0b1111011000: (9+1j), 
        0b1111011001: (9+3j), 0b1111011011: (9+5j), 0b1111011010: (9+7j), 
        0b1111011110: (9+9j), 0b1111011101: (9+13j), 0b1111011100: (9+15j), 
        0b1111010100: (9+17j), 0b1111010101: (9+19j), 0b1111010111: (9+21j), 
        0b1111010110: (9+23j), 0b1111010010: (9+25j), 0b1111010011: (9+27j),
        0b1111010001: (9+29j), 0b1111010000: (9+31j), 0b1111111000: (11+1j), 
        0b1111111001: (11+3j), 0b1111111011: (11+5j), 0b1111111010: (11+7j),
        0b1111111110: (11+9j), 0b1111111111: (11+11j), 0b1111111101: (11+13j),
        0b1111111100: (11+15j), 0b1111110100: (11+17j), 0b1111110101: (11+19j),
        0b1111110111: (11+21j), 0b1111110110: (11+23j), 0b1111110010: (11+25j),
        0b1111110011: (11+27j), 0b1111110001: (11+29j), 0b1111110000: (11+31j),
        0b1110111000: (13+1j), 0b1110111001: (13+3j), 0b1110111011: (13+5j),
        0b1110111010: (13+7j), 0b1110111110: (13+9j), 0b1110111111: (13+11j),
        0b1110111101: (13+13j), 0b1110111100: (13+15j), 0b1110110100: (13+17j),
        0b1110110101: (13+19j), 0b1110110111: (13+21j), 0b1110110110: (13+23j), 
        0b1110110010: (13+25j), 0b1110110011: (13+27j), 0b1110110001: (13+29j),
        0b1110110000: (13+31j), 0b1110011000: (15+1j), 0b1110011001: (15+3j),
        0b1110011011: (15+5j), 0b1110011010: (15+7j), 0b1110011110: (15+9j), 
        0b1110011111: (15+11j), 0b1110011101: (15+13j), 0b1110011100: (15+15j), 
        0b1110010100: (15+17j), 0b1110010101: (15+19j), 0b1110010111: (15+21j),
        0b1110010110: (15+23j), 0b1110010010: (15+25j), 0b1110010011: (15+27j),
        0b1110010001: (15+29j), 0b1110010000: (15+31j), 0b1010011000: (17+1j),
        0b1010011001: (17+3j), 0b1010011011: (17+5j), 0b1010011010: (17+7j),
        0b1010011110: (17+9j), 0b1010011111: (17+11j), 0b1010011101: (17+13j), 
        0b1010011100: (17+15j), 0b1010010100: (17+17j), 0b1010010101: (17+19j),
        0b1010010111: (17+21j), 0b1010010110: (17+23j), 0b1010010010: (17+25j),
        0b1010010011: (17+27j), 0b1010010001: (17+29j), 0b1010010000: (17+31j), 
        0b1010111000: (19+1j), 0b1010111001: (19+3j), 0b1010111011: (19+5j), 
        0b1010111010: (19+7j), 0b1010111110: (19+9j), 0b1010111111: (19+11j), 
        0b1010111101: (19+13j), 0b1010111100: (19+15j), 0b1010110100: (19+17j), 
        0b1010110101: (19+19j), 0b1010110111: (19+21j), 0b1010110110: (19+23j), 
        0b1010110010: (19+25j), 0b1010110011: (19+27j), 0b1010110001: (19+29j), 
        0b1010110000: (19+31j), 0b1011111000: (21+1j), 0b1011111001: (21+3j),
        0b1011111011: (21+5j), 0b1011111010: (21+7j), 0b1011111110: (21+9j),
        0b1011111111: (21+11j), 0b1011111101: (21+13j), 0b1011111100: (21+15j), 
        0b1011110100: (21+17j), 0b1011110101: (21+19j), 0b1011110111: (21+21j), 
        0b1011110110: (21+23j), 0b1011110010: (21+25j), 0b1011110011: (21+27j), 
        0b1011110001: (21+29j), 0b1011110000: (21+31j), 0b1011011000: (23+1j),
        0b1011011001: (23+3j), 0b1011011011: (23+5j), 0b1011011010: (23+7j),
        0b1011011110: (23+9j), 0b1011011111: (23+11j), 0b1011011101: (23+13j),
        0b1011011100: (23+15j), 0b1011010100: (23+17j), 0b1011010101: (23+19j), 
        0b1011010111: (23+21j), 0b1011010110: (23+23j), 0b1011010010: (23+25j), 
        0b1011010011: (23+27j), 0b1011010001: (23+29j), 0b1011010000: (23+31j), 
        0b1001011000: (25+1j), 0b1001011001: (25+3j), 0b1001011011: (25+5j),
        0b1001011010: (25+7j), 0b1001011110: (25+9j), 0b1001011111: (25+11j),
        0b1001011101: (25+13j), 0b1001011100: (25+15j), 0b1001010100: (25+17j), 
        0b1001010101: (25+19j), 0b1001010111: (25+21j), 0b1001010110: (25+23j), 
        0b1001010010: (25+25j), 0b1001010011: (25+27j), 0b1001010001: (25+29j),
        0b1001010000: (25+31j), 0b1001111000: (27+1j), 0b1001111001: (27+3j),
        0b1001111011: (27+5j), 0b1001111010: (27+7j), 0b1001111110: (27+9j),
        0b1001111111: (27+11j), 0b1001111101: (27+13j), 0b1001111100: (27+15j),
        0b1001110100: (27+17j), 0b1001110101: (27+19j), 0b1001110111: (27+21j),
        0b1001110110: (27+23j), 0b1001110010: (27+25j), 0b1001110011: (27+27j), 
        0b1001110001: (27+29j), 0b1001110000: (27+31j), 0b1000111000: (29+1j),
        0b1000111001: (29+3j), 0b1000111011: (29+5j), 0b1000111010: (29+7j),
        0b1000111110: (29+9j), 0b1000111111: (29+11j), 0b1000111101: (29+13j),
        0b1000111100: (29+15j), 0b1000110100: (29+17j), 0b1000110101: (29+19j), 
        0b1000110111: (29+21j), 0b1000110110: (29+23j), 0b1000110010: (29+25j),
        0b1000110011: (29+27j), 0b1000110001: (29+29j), 0b1000110000: (29+31j), 
        0b1000011000: (31+1j), 0b1000011001: (31+3j), 0b1000011011: (31+5j),
        0b1000011010: (31+7j), 0b1000011110: (31+9j), 0b1000011111: (31+11j),
        0b1000011101: (31+13j), 0b1000011100: (31+15j), 0b1000010100: (31+17j),
        0b1000010101: (31+19j), 0b1000010111: (31+21j), 0b1000010110: (31+23j), 
        0b1000010010: (31+25j), 0b1000010011: (31+27j), 0b1000010001: (31+29j), 
        0b1000010000: (31+31j), 0b1101111001: (5+3j), 0b1101111101: (5+13j),
        0b1101011111: (7+11j),
        # quadrant 2
        0b0100011000: (-1+1j), 0b0100011001: (-1+3j), 0b0100011011: (-1+5j),
        0b0100011010: (-1+7j), 0b0100011110: (-1+9j), 0b0100011101: (-1+13j),
        0b0100011100: (-1+15j), 0b0100010100: (-1+17j), 0b0100010101: (-1+19j),
        0b0100010111: (-1+21j), 0b0100010110: (-1+23j), 0b0100010010: (-1+25j),
        0b0100010011: (-1+27j), 0b0100010001: (-1+29j), 0b0100010000: (-1+31j), 
        0b0100111000: (-3+1j), 0b0100111001: (-3+3j), 0b0100111011: (-3+5j),
        0b0100111010: (-3+7j), 0b0100111110: (-3+9j), 0b0100111111: (-3+11j), 
        0b0100111101: (-3+13j), 0b0100111100: (-3+15j), 0b0100110100: (-3+17j), 
        0b0100110101: (-3+19j), 0b0100110111: (-3+21j), 0b0100110110: (-3+23j), 
        0b0100110010: (-3+25j), 0b0100110011: (-3+27j), 0b0100110001: (-3+29j), 
        0b0100110000: (-3+31j), 0b0101111000: (-5+1j), 0b0101111001: (-5+3j),
        0b0101111011: (-5+5j), 0b0101111010: (-5+7j), 0b0101111110: (-5+9j),
        0b0101111111: (-5+11j), 0b0101111101: (-5+13j), 0b0101111100: (-5+15j),
        0b0101110100: (-5+17j), 0b0101110101: (-5+19j), 0b0101110111: (-5+21j),
        0b0101110110: (-5+23j), 0b0101110010: (-5+25j), 0b0101110011: (-5+27j),
        0b0101110001: (-5+29j), 0b0101110000: (-5+31j), 0b0101011000: (-7+1j), 
        0b0101011001: (-7+3j), 0b0101011011: (-7+5j), 0b0101011010: (-7+7j),
        0b0101011110: (-7+9j), 0b0101011111: (-7+11j), 0b0101011101: (-7+13j),
        0b0101011100: (-7+15j), 0b0101010100: (-7+17j), 0b0101010101: (-7+19j),
        0b0101010111: (-7+21j), 0b0101010110: (-7+23j), 0b0101010010: (-7+25j), 
        0b0101010011: (-7+27j), 0b0101010001: (-7+29j), 0b0101010000: (-7+31j),
        0b0111011000: (-9+1j), 0b0111011001: (-9+3j), 0b0111011011: (-9+5j),
        0b0111011010: (-9+7j), 0b0111011110: (-9+9j), 0b0111011111: (-9+11j),
        0b0111011101: (-9+13j), 0b0111011100: (-9+15j), 0b0111010100: (-9+17j),
        0b0111010101: (-9+19j), 0b0111010111: (-9+21j), 0b0111010110: (-9+23j),
        0b0111010010: (-9+25j), 0b0111010011: (-9+27j), 0b0111010001: (-9+29j), 
        0b0111010000: (-9+31j), 0b0111111000: (-11+1j), 0b0111111001: (-11+3j),
        0b0111111011: (-11+5j), 0b0111111010: (-11+7j), 0b0111111110: (-11+9j), 
        0b0111111111: (-11+11j), 0b0111111101: (-11+13j), 0b0111111100: (-11+15j),
        0b0111110100: (-11+17j), 0b0111110101: (-11+19j), 0b0111110111: (-11+21j),
        0b0111110110: (-11+23j), 0b0111110010: (-11+25j), 0b0111110011: (-11+27j),
        0b0111110001: (-11+29j), 0b0111110000: (-11+31j), 0b0110111000: (-13+1j),
        0b0110111001: (-13+3j), 0b0110111011: (-13+5j), 0b0110111010: (-13+7j), 
        0b0110111110: (-13+9j), 0b0110111111: (-13+11j), 0b0110111101: (-13+13j), 
        0b0110111100: (-13+15j), 0b0110110100: (-13+17j), 0b0110110101: (-13+19j),
        0b0110110111: (-13+21j), 0b0110110110: (-13+23j), 0b0110110010: (-13+25j),
        0b0110110011: (-13+27j), 0b0110110001: (-13+29j), 0b0110110000: (-13+31j),
        0b0110011000: (-15+1j), 0b0110011001: (-15+3j), 0b0110011011: (-15+5j), 
        0b0110011010: (-15+7j), 0b0110011110: (-15+9j), 0b0110011111: (-15+11j), 
        0b0110011101: (-15+13j), 0b0110011100: (-15+15j), 0b0110010100: (-15+17j),
        0b0110010101: (-15+19j), 0b0110010111: (-15+21j), 0b0110010110: (-15+23j),
        0b0110010010: (-15+25j), 0b0110010011: (-15+27j), 0b0110010001: (-15+29j),
        0b0110010000: (-15+31j), 0b0010011000: (-17+1j), 0b0010011001: (-17+3j), 
        0b0010011011: (-17+5j), 0b0010011010: (-17+7j), 0b0010011110: (-17+9j),
        0b0010011111: (-17+11j), 0b0010011101: (-17+13j), 0b0010011100: (-17+15j),
        0b0010010100: (-17+17j), 0b0010010101: (-17+19j), 0b0010010111: (-17+21j),
        0b0010010110: (-17+23j), 0b0010010010: (-17+25j), 0b0010010011: (-17+27j), 
        0b0010010001: (-17+29j), 0b0010010000: (-17+31j), 0b0010111000: (-19+1j),
        0b0010111001: (-19+3j), 0b0010111011: (-19+5j), 0b0010111010: (-19+7j), 
        0b0010111110: (-19+9j), 0b0010111111: (-19+11j), 0b0010111101: (-19+13j), 
        0b0010111100: (-19+15j), 0b0010110100: (-19+17j), 0b0010110101: (-19+19j),
        0b0010110111: (-19+21j), 0b0010110110: (-19+23j), 0b0010110010: (-19+25j), 
        0b0010110011: (-19+27j), 0b0010110001: (-19+29j), 0b0010110000: (-19+31j), 
        0b0011111000: (-21+1j), 0b0011111001: (-21+3j), 0b0011111011: (-21+5j),
        0b0011111010: (-21+7j), 0b0011111110: (-21+9j), 0b0011111111: (-21+11j), 
        0b0011111101: (-21+13j), 0b0011111100: (-21+15j), 0b0011110100: (-21+17j),
        0b0011110101: (-21+19j), 0b0011110111: (-21+21j), 0b0011110110: (-21+23j), 
        0b0011110010: (-21+25j), 0b0011110011: (-21+27j), 0b0011110001: (-21+29j), 
        0b0011110000: (-21+31j), 0b0011011000: (-23+1j), 0b0011011001: (-23+3j),
        0b0011011011: (-23+5j), 0b0011011010: (-23+7j), 0b0011011110: (-23+9j),
        0b0011011111: (-23+11j), 0b0011011101: (-23+13j), 0b0011011100: (-23+15j),
        0b0011010100: (-23+17j), 0b0011010101: (-23+19j), 0b0011010111: (-23+21j), 
        0b0011010110: (-23+23j), 0b0011010010: (-23+25j), 0b0011010011: (-23+27j),
        0b0011010001: (-23+29j), 0b0011010000: (-23+31j), 0b001011000: (-25+1j),
        0b0001011001: (-25+3j), 0b0001011011: (-25+5j), 0b0001011010: (-25+7j), 
        0b0001011110: (-25+9j), 0b0001011111: (-25+11j), 0b0001011101: (-25+13j), 
        0b0001011100: (-25+15j), 0b0001010100: (-25+17j), 0b0001010101: (-25+19j),
        0b0001010111: (-25+21j), 0b0001010110: (-25+23j), 0b0001010010: (-25+25j),
        0b0001010011: (-25+27j), 0b0001010001: (-25+29j), 0b0001010000: (-25+31j),
        0b0001111000: (-27+1j), 0b0001111001: (-27+3j), 0b0001111011: (-27+5j), 
        0b0001111010: (-27+7j), 0b0001111110: (-27+9j), 0b0001111111: (-27+11j),
        0b0001111101: (-27+13j), 0b0001111100: (-27+15j), 0b0001110100: (-27+17j),
        0b0001110101: (-27+19j), 0b0001110111: (-27+21j), 0b0001110110: (-27+23j), 
        0b0001110010: (-27+25j), 0b0001110011: (-27+27j), 0b0001110001: (-27+29j), 
        0b0001110000: (-27+31j), 0b000111000: (-29+1j), 0b0000111001: (-29+3j), 
        0b0000111011: (-29+5j), 0b0000111010: (-29+7j), 0b0000111110: (-29+9j), 
        0b0000111111: (-29+11j), 0b0000111101: (-29+13j), 0b0000111100: (-29+15j),
        0b0000110100: (-29+17j), 0b0000110101: (-29+19j), 0b0000110111: (-29+21j),
        0b0000110110: (-29+23j), 0b0000110010: (-29+25j), 0b0000110011: (-29+27j),
        0b0000110001: (-29+29j), 0b0000110000: (-29+31j), 0b0000011100: (-31+15j),
        0b0000011001: (-31+3j), 0b0000011011: (-31+5j), 0b0000011010: (-31+7j),
        0b0000011110: (-31+9j), 0b0000011111: (-31+11j), 0b0000011101: (-31+13j),
        0b0000010100: (-31+17j), 0b0000010101: (-31+19j), 0b0000010111: (-31+21j),
        0b0000010110: (-31+23j), 0b0000010010: (-31+25j), 0b0000010011: (-31+27j), 
        0b0000010001: (-31+29j), 0b0000010000: (-31+31j), 0b0000011000: (-31+1j),
        0b0100011111: (-1+11j),
        # third quadrant
        0b0100001000: (-1-1j), 0b0100001001: (-1-3j), 0b0100001011: (-1-5j), 
        0b0100001010: (-1-7j), 0b0100001110: (-1-9j), 0b0100001111: (-1-11j), 
        0b0100001101: (-1-13j), 0b0100001100: (-1-15j), 0b0100000100: (-1-17j),
        0b0100000101: (-1-19j), 0b0100000111: (-1-21j), 0b0100000110: (-1-23j), 
        0b0100000010: (-1-25j), 0b0100000011: (-1-27j), 0b0100000001: (-1-29j), 
        0b0100000000: (-1-31j), 0b0100101000: (-3-1j), 0b0100101001: (-3-3j), 
        0b0100101011: (-3-5j), 0b0100101010: (-3-7j), 0b0100101110: (-3-9j), 
        0b0100101111: (-3-11j), 0b0100101101: (-3-13j), 0b0100101100: (-3-15j), 
        0b0100100100: (-3-17j), 0b0100100101: (-3-19j), 0b0100100111: (-3-21j),
        0b0100100110: (-3-23j), 0b0100100010: (-3-25j), 0b0100100011: (-3-27j),
        0b0100100001: (-3-29j), 0b0100100000: (-3-31j), 0b0101101000: (-5-1j), 
        0b0101101001: (-5-3j), 0b0101101011: (-5-5j), 0b0101101010: (-5-7j),
        0b0101101110: (-5-9j), 0b0101101111: (-5-11j), 0b0101101101: (-5-13j),
        0b0101101100: (-5-15j), 0b0101100100: (-5-17j), 0b0101100101: (-5-19j),
        0b0101100111: (-5-21j), 0b0101100110: (-5-23j), 0b0101100010: (-5-25j),
        0b0101100011: (-5-27j), 0b0101100001: (-5-29j), 0b0101100000: (-5-31j), 
        0b0101001000: (-7-1j), 0b0101001001: (-7-3j), 0b0101001011: (-7-5j), 
        0b0101001010: (-7-7j), 0b0101001110: (-7-9j), 0b0101001111: (-7-11j), 
        0b0101001101: (-7-13j), 0b0101001100: (-7-15j), 0b0101000100: (-7-17j),
        0b0101000101: (-7-19j), 0b0101000111: (-7-21j), 0b0101000110: (-7-23j), 
        0b0101000010: (-7-25j), 0b0101000011: (-7-27j), 0b0101000001: (-7-29j), 
        0b0101000000: (-7-31j), 0b0111001000: (-9-1j), 0b0111001001: (-9-3j), 
        0b0111001011: (-9-5j), 0b0111001010: (-9-7j), 0b0111001110: (-9-9j), 
        0b0111001111: (-9-11j), 0b0111001101: (-9-13j), 0b0111001100: (-9-15j),
        0b0111000100: (-9-17j), 0b0111000101: (-9-19j), 0b0111000111: (-9-21j), 
        0b0111000110: (-9-23j), 0b0111000010: (-9-25j), 0b0111000011: (-9-27j),
        0b0111000001: (-9-29j), 0b0111000000: (-9-31j), 0b0111101000: (-11-1j),
        0b0111101001: (-11-3j), 0b0111101011: (-11-5j), 0b0111101010: (-11-7j), 
        0b0111101110: (-11-9j), 0b0111101111: (-11-11j), 0b0111101101: (-11-13j), 
        0b0111101100: (-11-15j), 0b0111100100: (-11-17j), 0b0111100101: (-11-19j),
        0b0111100111: (-11-21j), 0b0111100110: (-11-23j), 0b0111100010: (-11-25j),
        0b0111100011: (-11-27j), 0b0111100001: (-11-29j), 0b0111100000: (-11-31j),
        0b0110101000: (-13-1j), 0b0110101001: (-13-3j), 0b0110101011: (-13-5j), 
        0b0110101010: (-13-7j), 0b0110101110: (-13-9j), 0b0110101111: (-13-11j), 
        0b0110101101: (-13-13j), 0b0110101100: (-13-15j), 0b0110100100: (-13-17j),
        0b0110100101: (-13-19j), 0b0110100111: (-13-21j), 0b0110100110: (-13-23j),
        0b0110100010: (-13-25j), 0b0110100011: (-13-27j), 0b0110100001: (-13-29j),
        0b0110100000: (-13-31j), 0b0110001000: (-15-1j), 0b0110001001: (-15-3j), 
        0b0110001011: (-15-5j), 0b0110001010: (-15-7j), 0b0110001110: (-15-9j),
        0b0110001111: (-15-11j), 0b0110001101: (-15-13j), 0b0110001100: (-15-15j), 
        0b0110000100: (-15-17j), 0b0110000101: (-15-19j), 0b0110000111: (-15-21j),
        0b0110000110: (-15-23j), 0b0110000010: (-15-25j), 0b0110000011: (-15-27j),
        0b0110000001: (-15-29j), 0b0110000000: (-15-31j), 0b0010001000: (-17-1j), 
        0b0010001001: (-17-3j), 0b0010001011: (-17-5j), 0b0010001010: (-17-7j), 
        0b0010001110: (-17-9j), 0b0010001111: (-17-11j), 0b0010001101: (-17-13j),
        0b0010001100: (-17-15j), 0b0010000100: (-17-17j), 0b0010000101: (-17-19j),
        0b0010000111: (-17-21j), 0b0010000110: (-17-23j), 0b0010000010: (-17-25j), 
        0b0010000011: (-17-27j), 0b0010000001: (-17-29j), 0b0010000000: (-17-31j),
        0b0010101000: (-19-1j), 0b0010101001: (-19-3j), 0b0010101011: (-19-5j), 
        0b0010101010: (-19-7j), 0b0010101110: (-19-9j), 0b0010101111: (-19-11j),
        0b0010101101: (-19-13j), 0b0010101100: (-19-15j), 0b0010100100: (-19-17j),
        0b0010100101: (-19-19j), 0b0010100111: (-19-21j), 0b0010100110: (-19-23j),
        0b0010100010: (-19-25j), 0b0010100011: (-19-27j), 0b0010100001: (-19-29j),
        0b0010100000: (-19-31j), 0b0011101000: (-21-1j), 0b0011101001: (-21-3j), 
        0b0011101011: (-21-5j), 0b0011101010: (-21-7j), 0b0011101110: (-21-9j),
        0b0011101111: (-21-11j), 0b0011101101: (-21-13j), 0b0011101100: (-21-15j),
        0b0011100100: (-21-17j), 0b0011100101: (-21-19j), 0b0011100111: (-21-21j), 
        0b0011100110: (-21-23j), 0b0011100010: (-21-25j), 0b0011100011: (-21-27j), 
        0b0011100001: (-21-29j), 0b0011100000: (-21-31j), 0b0011001000: (-23-1j),
        0b0011001001: (-23-3j), 0b0011001011: (-23-5j), 0b0011001010: (-23-7j), 
        0b0011001110: (-23-9j), 0b0011001111: (-23-11j), 0b0011001101: (-23-13j),
        0b0011001100: (-23-15j), 0b0011000100: (-23-17j), 0b0011000101: (-23-19j), 
        0b0011000111: (-23-21j), 0b0011000110: (-23-23j), 0b0011000010: (-23-25j),
        0b0011000011: (-23-27j), 0b0011000001: (-23-29j), 0b0011000000: (-23-31j), 
        0b0001001000: (-25-1j), 0b0001001001: (-25-3j), 0b0001001011: (-25-5j), 
        0b0001001010: (-25-7j), 0b0001001110: (-25-9j), 0b0001001111: (-25-11j), 
        0b0001001101: (-25-13j), 0b0001001100: (-25-15j), 0b0001000100: (-25-17j),
        0b0001000101: (-25-19j), 0b0001000111: (-25-21j), 0b0001000110: (-25-23j),
        0b0001000010: (-25-25j), 0b0001000011: (-25-27j), 0b0001000001: (-25-29j), 
        0b0001000000: (-25-31j), 0b0001101000: (-27-1j), 0b0001101001: (-27-3j), 
        0b0001101011: (-27-5j), 0b0001101010: (-27-7j), 0b0001101110: (-27-9j), 
        0b0001101111: (-27-11j), 0b0001101101: (-27-13j), 0b0001101100: (-27-15j),
        0b0001100100: (-27-17j), 0b0001100101: (-27-19j), 0b0001100111: (-27-21j), 
        0b0001100110: (-27-23j), 0b0001100010: (-27-25j), 0b0001100011: (-27-27j), 
        0b0001100001: (-27-29j), 0b0001100000: (-27-31j), 0b0000101000: (-29-1j), 
        0b0000101001: (-29-3j), 0b0000101011: (-29-5j), 0b0000101010: (-29-7j), 
        0b0000101110: (-29-9j), 0b0000101111: (-29-11j), 0b0000101101: (-29-13j), 
        0b0000101100: (-29-15j), 0b0000100100: (-29-17j), 0b0000100101: (-29-19j), 
        0b0000100111: (-29-21j), 0b0000100110: (-29-23j), 0b0000100010: (-29-25j), 
        0b0000100011: (-29-27j), 0b0000100001: (-29-29j), 0b0000100000: (-29-31j),
        0b0000001000: (-31-1j), 0b0000001001: (-31-3j), 0b0000001011: (-31-5j), 
        0b0000001010: (-31-7j), 0b0000001110: (-31-9j), 0b0000001111: (-31-11j),
        0b0000001101: (-31-13j), 0b0000001100: (-31-15j), 0b0000000100: (-31-17j), 
        0b0000000101: (-31-19j), 0b0000000111: (-31-21j), 0b0000000110: (-31-23j),
        0b0000000010: (-31-25j), 0b0000000011: (-31-27j), 0b0000000001: (-31-29j), 
        0b0000000000: (-31-31j),
        # fourth quadrant
        0b1100001000: (1-1j), 0b1100001001: (1-3j), 0b1100001011: (1-5j), 
        0b1100001010: (1-7j), 0b1100001110: (1-9j), 0b1100001111: (1-11j),
        0b1100001101: (1-13j), 0b1100001100: (1-15j), 0b1100000100: (1-17j), 
        0b1100000101: (1-19j), 0b1100000111: (1-21j), 0b1100000110: (1-23j),
        0b1100000010: (1-25j), 0b1100000011: (1-27j), 0b1100000001: (1-29j),
        0b1100000000: (1-31j), 0b1100101000: (3-1j), 0b1100101001: (3-3j),
        0b1100101011: (3-5j), 0b1100101010: (3-7j), 0b1100101110: (3-9j), 
        0b1100101111: (3-11j), 0b1100101101: (3-13j), 0b1100101100: (3-15j),
        0b1100100100: (3-17j), 0b1100100101: (3-19j), 0b1100100111: (3-21j),
        0b1100100110: (3-23j), 0b1100100010: (3-25j), 0b1100100011: (3-27j),
        0b1100100001: (3-29j), 0b1100100000: (3-31j), 0b1101101000: (5-1j), 
        0b1101101001: (5-3j), 0b1101101011: (5-5j), 0b1101101010: (5-7j), 
        0b1101101110: (5-9j), 0b1101101111: (5-11j), 0b1101101101: (5-13j),
        0b1101101100: (5-15j), 0b1101100100: (5-17j), 0b1101100101: (5-19j),
        0b1101100111: (5-21j), 0b1101100110: (5-23j), 0b1101100010: (5-25j),
        0b1101100011: (5-27j), 0b1101100001: (5-29j), 0b1101100000: (5-31j),
        0b1101001000: (7-1j), 0b1101001001: (7-3j), 0b1101001011: (7-5j), 
        0b1101001010: (7-7j), 0b1101001110: (7-9j), 0b1101001111: (7-11j), 
        0b1101001101: (7-13j), 0b1101001100: (7-15j), 0b1101000100: (7-17j),
        0b1101000101: (7-19j), 0b1101000111: (7-21j), 0b1101000110: (7-23j),
        0b1101000010: (7-25j), 0b1101000011: (7-27j), 0b1101000001: (7-29j),
        0b1101000000: (7-31j), 0b1111001000: (9-1j), 0b1111001001: (9-3j),
        0b1111001011: (9-5j), 0b1111001010: (9-7j), 0b1111001110: (9-9j),
        0b1111001111: (9-11j), 0b1111001101: (9-13j), 0b1111001100: (9-15j), 
        0b1111000100: (9-17j), 0b1111000101: (9-19j), 0b1111000111: (9-21j), 
        0b1111000110: (9-23j), 0b1111000010: (9-25j), 0b1111000011: (9-27j), 
        0b1111000001: (9-29j), 0b1111000000: (9-31j), 0b1111101000: (11-1j),
        0b1111101001: (11-3j), 0b1111101011: (11-5j), 0b1111101010: (11-7j),
        0b1111101110: (11-9j), 0b1111101111: (11-11j), 0b1111101101: (11-13j),
        0b1111101100: (11-15j), 0b1111100100: (11-17j), 0b1111100101: (11-19j),
        0b1111100111: (11-21j), 0b1111100110: (11-23j), 0b1111100010: (11-25j), 
        0b1111100011: (11-27j), 0b1111100001: (11-29j), 0b1111100000: (11-31j), 
        0b1110101000: (13-1j), 0b1110101001: (13-3j), 0b1110101011: (13-5j), 
        0b1110101010: (13-7j), 0b1110101110: (13-9j), 0b1110101111: (13-11j),
        0b1110101101: (13-13j), 0b1110101100: (13-15j), 0b1110100100: (13-17j),
        0b1110100101: (13-19j), 0b1110100111: (13-21j), 0b1110100110: (13-23j),
        0b1110100010: (13-25j), 0b1110100011: (13-27j), 0b1110100001: (13-29j), 
        0b1110100000: (13-31j), 0b1110001000: (15-1j), 0b1110001001: (15-3j), 
        0b1110001011: (15-5j), 0b1110001010: (15-7j), 0b1110001110: (15-9j), 
        0b1110001111: (15-11j), 0b1110001101: (15-13j), 0b1110001100: (15-15j),
        0b1110000100: (15-17j), 0b1110000101: (15-19j), 0b1110000111: (15-21j),
        0b1110000110: (15-23j), 0b1110000010: (15-25j), 0b1110000011: (15-27j),
        0b1110000001: (15-29j), 0b1110000000: (15-31j), 0b1010001000: (17-1j), 
        0b1010001001: (17-3j), 0b1010001011: (17-5j), 0b1010001010: (17-7j),
        0b1010001110: (17-9j), 0b1010001111: (17-11j), 0b1010001101: (17-13j), 
        0b1010001100: (17-15j), 0b1010000100: (17-17j), 0b1010000101: (17-19j),
        0b1010000111: (17-21j), 0b1010000110: (17-23j), 0b1010000010: (17-25j),
        0b1010000011: (17-27j), 0b1010000001: (17-29j), 0b1010000000: (17-31j), 
        0b1010101000: (19-1j), 0b1010101001: (19-3j), 0b1010101011: (19-5j),
        0b1010101010: (19-7j), 0b1010101110: (19-9j), 0b1010101111: (19-11j), 
        0b1010101101: (19-13j), 0b1010101100: (19-15j), 0b1010100100: (19-17j), 
        0b1010100101: (19-19j), 0b1010100111: (19-21j), 0b1010100110: (19-23j),
        0b1010100010: (19-25j), 0b1010100011: (19-27j), 0b1010100001: (19-29j), 
        0b1010100000: (19-31j), 0b1011101000: (21-1j), 0b1011101001: (21-3j), 
        0b1011101011: (21-5j), 0b1011101010: (21-7j), 0b1011101110: (21-9j), 
        0b1011101111: (21-11j), 0b1011101101: (21-13j), 0b1011101100: (21-15j),
        0b1011100100: (21-17j), 0b1011100101: (21-19j), 0b1011100111: (21-21j),
        0b1011100110: (21-23j), 0b1011100010: (21-25j), 0b1011100011: (21-27j),
        0b1011100001: (21-29j), 0b1011100000: (21-31j), 0b1011001000: (23-1j),
        0b1011001001: (23-3j), 0b1011001011: (23-5j), 0b1011001010: (23-7j), 
        0b1011001110: (23-9j), 0b1011001111: (23-11j), 0b1011001101: (23-13j),
        0b1011001100: (23-15j), 0b1011000100: (23-17j), 0b1011000101: (23-19j), 
        0b1011000111: (23-21j), 0b1011000110: (23-23j), 0b1011000010: (23-25j),
        0b1011000011: (23-27j), 0b1011000001: (23-29j), 0b1011000000: (23-31j),
        0b1001001000: (25-1j), 0b1001001001: (25-3j), 0b1001001011: (25-5j),
        0b1001001010: (25-7j), 0b1001001110: (25-9j), 0b1001001111: (25-11j),
        0b1001001101: (25-13j), 0b1001001100: (25-15j), 0b1001000100: (25-17j), 
        0b1001000101: (25-19j), 0b1001000111: (25-21j), 0b1001000110: (25-23j),
        0b1001000010: (25-25j), 0b1001000011: (25-27j), 0b1001000001: (25-29j),
        0b1001000000: (25-31j), 0b1001101000: (27-1j), 0b1001101001: (27-3j),
        0b1001101011: (27-5j), 0b1001101010: (27-7j), 0b1001101110: (27-9j), 
        0b1001101111: (27-11j), 0b1001101101: (27-13j), 0b1001101100: (27-15j),
        0b1001100100: (27-17j), 0b1001100101: (27-19j), 0b1001100111: (27-21j),
        0b1001100110: (27-23j), 0b1001100010: (27-25j), 0b1001100011: (27-27j),
        0b1001100001: (27-29j), 0b1001100000: (27-31j), 0b1000101000: (29-1j), 
        0b1000101001: (29-3j), 0b1000101011: (29-5j), 0b1000101010: (29-7j),
        0b1000101110: (29-9j), 0b1000101111: (29-11j), 0b1000101101: (29-13j),
        0b1000101100: (29-15j), 0b1000100100: (29-17j), 0b1000100101: (29-19j),
        0b1000100111: (29-21j), 0b1000100110: (29-23j), 0b1000100010: (29-25j),
        0b1000100011: (29-27j), 0b1000100001: (29-29j), 0b1000100000: (29-31j),
        0b1000001000: (31-1j), 0b1000001001: (31-3j), 0b1000001011: (31-5j),
        0b1000001010: (31-7j), 0b1000001110: (31-9j), 0b1000001111: (31-11j),
        0b1000001101: (31-13j), 0b1000001100: (31-15j), 0b1000000100: (31-17j), 
        0b1000000101: (31-19j), 0b1000000111: (31-21j), 0b1000000110: (31-23j),
        0b1000000010: (31-25j), 0b1000000011: (31-27j), 0b1000000001: (31-29j), 
        0b1000000000: (31-31j)
        }
    qam1024_nbits  = 10
    qam1024_kmod   = 1/(682**0.5)
    
    # 256-QAM constellation (802.11-2020 sec 21.3.10.9)
    qam256_c = {
        0b11001100: (1+1j), 0b11001101: (1+3j), 0b11001111: (1+5j), 0b11001110: (1+7j), 
        0b11001010: (1+9j), 0b11001011: (1+11j), 0b11001001: (1+13j), 0b11001000: (1+15j), 
        0b11011100: (3+1j), 0b11011101: (3+3j), 0b11011111: (3+5j), 0b11011110: (3+7j),
        0b11011010: (3+9j), 0b11011011: (3+11j), 0b11011001: (3+13j), 0b11011000: (3+15j),
        0b11111100: (5+1j), 0b11111101: (5+3j), 0b11111111: (5+5j), 0b11111110: (5+7j),
        0b11111010: (5+9j), 0b11111011: (5+11j), 0b11111001: (5+13j), 0b11111000: (5+15j),
        0b11101100: (7+1j), 0b11101101: (7+3j), 0b11101111: (7+5j), 0b11101110: (7+7j), 
        0b11101010: (7+9j), 0b11101011: (7+11j), 0b11101001: (7+13j), 0b11101000: (7+15j), 
        0b10101100: (9+1j), 0b10101101: (9+3j), 0b10101111: (9+5j), 0b10101110: (9+7j),
        0b10101010: (9+9j), 0b10101011: (9+11j), 0b10101001: (9+13j), 0b10101000: (9+15j), 
        0b10111100: (11+1j), 0b10111101: (11+3j), 0b10111111: (11+5j), 0b10111110: (11+7j), 
        0b10111010: (11+9j), 0b10111011: (11+11j), 0b10111001: (11+13j), 0b10111000: (11+15j), 
        0b10011100: (13+1j), 0b10011101: (13+3j), 0b10011111: (13+5j), 0b10011110: (13+7j),
        0b10011010: (13+9j), 0b10011011: (13+11j), 0b10011001: (13+13j), 0b10011000: (13+15j), 
        0b10001100: (15+1j), 0b10001101: (15+3j), 0b10001111: (15+5j), 0b10001110: (15+7j), 
        0b10001010: (15+9j), 0b10001011: (15+11j), 0b10001001: (15+13j), 0b10001000: (15+15j),
        0b01001100: (-1+1j), 0b01001101: (-1+3j), 0b01001111: (-1+5j), 0b01001110: (-1+7j), 
        0b01001010: (-1+9j), 0b01001011: (-1+11j), 0b01001001: (-1+13j), 0b01001000: (-1+15j),
        0b01011100: (-3+1j), 0b01011101: (-3+3j), 0b01011111: (-3+5j), 0b01011110: (-3+7j), 
        0b01011010: (-3+9j), 0b01011011: (-3+11j), 0b01011001: (-3+13j), 0b01011000: (-3+15j), 
        0b01111100: (-5+1j), 0b01111101: (-5+3j), 0b01111111: (-5+5j), 0b01111110: (-5+7j), 
        0b01111010: (-5+9j), 0b01111011: (-5+11j), 0b01111001: (-5+13j), 0b01111000: (-5+15j), 
        0b01101100: (-7+1j), 0b01101101: (-7+3j), 0b01101111: (-7+5j), 0b01101110: (-7+7j), 
        0b01101010: (-7+9j), 0b01101011: (-7+11j), 0b01101001: (-7+13j), 0b01101000: (-7+15j),
        0b00101100: (-9+1j), 0b00101101: (-9+3j), 0b00101111: (-9+5j), 0b00101110: (-9+7j), 
        0b00101010: (-9+9j), 0b00101011: (-9+11j), 0b00101001: (-9+13j), 0b00101000: (-9+15j), 
        0b00111100: (-11+1j), 0b00111101: (-11+3j), 0b00111111: (-11+5j), 0b00111110: (-11+7j),
        0b00111010: (-11+9j), 0b00111011: (-11+11j), 0b00111001: (-11+13j), 0b00111000: (-11+15j),
        0b00011100: (-13+1j), 0b00011101: (-13+3j), 0b00011111: (-13+5j), 0b00011110: (-13+7j),
        0b00011010: (-13+9j), 0b00011011: (-13+11j), 0b00011001: (-13+13j), 0b00011000: (-13+15j), 
        0b00001100: (-15+1j), 0b00001101: (-15+3j), 0b00001111: (-15+5j), 0b00001110: (-15+7j), 
        0b0001010: (-15+9j), 0b0001011: (-15+11j), 0b0001001: (-15+13j), 0b0001000: (-15+15j),
        0b01000100: (-1-1j), 0b01000101: (-1-3j), 0b01000111: (-1-5j), 0b01000110: (-1-7j),
        0b01000010: (-1-9j), 0b01000011: (-1-11j), 0b01000001: (-1-13j), 0b01000000: (-1-15j),
        0b01010100: (-3-1j), 0b01010101: (-3-3j), 0b01010111: (-3-5j), 0b01010110: (-3-7j),
        0b01010010: (-3-9j), 0b01010011: (-3-11j), 0b01010001: (-3-13j), 0b01010000: (-3-15j), 
        0b01110100: (-5-1j), 0b01110101: (-5-3j), 0b01110111: (-5-5j), 0b01110110: (-5-7j),
        0b01110010: (-5-9j), 0b01110011: (-5-11j), 0b01110001: (-5-13j), 0b01110000: (-5-15j), 
        0b01100100: (-7-1j), 0b01100101: (-7-3j), 0b01100111: (-7-5j), 0b01100110: (-7-7j), 
        0b01100010: (-7-9j), 0b01100011: (-7-11j), 0b01100001: (-7-13j), 0b01100000: (-7-15j),
        0b00100100: (-9-1j), 0b00100101: (-9-3j), 0b00100111: (-9-5j), 0b00100110: (-9-7j), 
        0b00100010: (-9-9j), 0b00100011: (-9-11j), 0b00100001: (-9-13j), 0b00100000: (-9-15j), 
        0b00110100: (-11-1j), 0b00110101: (-11-3j), 0b00110111: (-11-5j), 0b00110110: (-11-7j),
        0b00110010: (-11-9j), 0b00110011: (-11-11j), 0b00110001: (-11-13j), 0b00110000: (-11-15j),
        0b00010100: (-13-1j), 0b00010101: (-13-3j), 0b00010111: (-13-5j), 0b00010110: (-13-7j), 
        0b00010010: (-13-9j), 0b00010011: (-13-11j), 0b00010001: (-13-13j), 0b00010000: (-13-15j),
        0b00000100: (-15-1j), 0b00000101: (-15-3j), 0b00000111: (-15-5j), 0b00000110: (-15-7j),
        0b00000010: (-15-9j), 0b00000011: (-15-11j), 0b00000001: (-15-13j), 0b00000000: (-15-15j),
        0b11000100: (1-1j), 0b11000101: (1-3j), 0b11000111: (1-5j), 0b11000110: (1-7j), 
        0b11000010: (1-9j), 0b11000011: (1-11j), 0b11000001: (1-13j), 0b11000000: (1-15j),
        0b11010100: (3-1j), 0b11010101: (3-3j), 0b11010111: (3-5j), 0b11010110: (3-7j),
        0b11010010: (3-9j), 0b11010011: (3-11j), 0b11010001: (3-13j), 0b11010000: (3-15j), 
        0b11110100: (5-1j), 0b11110101: (5-3j), 0b11110111: (5-5j), 0b11110110: (5-7j), 
        0b11110010: (5-9j), 0b11110011: (5-11j), 0b11110001: (5-13j), 0b11110000: (5-15j), 
        0b11100100: (7-1j), 0b11100101: (7-3j), 0b11100111: (7-5j), 0b11100110: (7-7j),
        0b11100010: (7-9j), 0b11100011: (7-11j), 0b11100001: (7-13j), 0b11100000: (7-15j),
        0b10100100: (9-1j), 0b10100101: (9-3j), 0b10100111: (9-5j), 0b10100110: (9-7j),
        0b10100010: (9-9j), 0b10100011: (9-11j), 0b10100001: (9-13j), 0b10100000: (9-15j), 
        0b10110100: (11-1j), 0b10110101: (11-3j), 0b10110111: (11-5j), 0b10110110: (11-7j),
        0b10110010: (11-9j), 0b10110011: (11-11j), 0b10110001: (11-13j), 0b10110000: (11-15j),
        0b10010100: (13-1j), 0b10010101: (13-3j), 0b10010111: (13-5j), 0b10010110: (13-7j), 
        0b10010010: (13-9j), 0b10010011: (13-11j), 0b10010001: (13-13j), 0b10010000: (13-15j),
        0b10000100: (15-1j), 0b10000101: (15-3j), 0b10000111: (15-5j), 0b10000110: (15-7j), 
        0b10000010: (15-9j), 0b10000011: (15-11j), 0b10000001: (15-13j), 0b10000000: (15-15j)
        }
    qam256_nbits    = 8
    qam256_kmod     = 1/(170**0.5)
    
    # 64-QAM constellation (802.11-2020 sec 17.3.5.8)
    qam64_c = {
        0b000000: (-7-7j), 0b000001: (-7-5j), 0b000011: (-7-3j), 0b000010: (-7-1j), 
        0b000110: (-7+1j), 0b000111: (-7+3j), 0b000101: (-7+5j), 0b000100: (-7+7j),
        0b001000: (-5-7j), 0b001001: (-5-5j), 0b001011: (-5-3j), 0b001010: (-5-1j), 
        0b001110: (-5+1j), 0b001111: (-5+3j), 0b001101: (-5+5j), 0b001100: (-5+7j), 
        0b011000: (-3-7j), 0b011001: (-3-5j), 0b011011: (-3-3j), 0b011010: (-3-1j), 
        0b011110: (-3+1j), 0b011111: (-3+3j), 0b011101: (-3+5j), 0b011100: (-3+7j), 
        0b010000: (-1-7j), 0b010001: (-1-5j), 0b010011: (-1-3j), 0b010010: (-1-1j), 
        0b010110: (-1+1j), 0b010111: (-1+3j), 0b010101: (-1+5j), 0b010100: (-1+7j),
        0b110000: (1-7j), 0b110001: (1-5j), 0b110011: (1-3j), 0b110010: (1-1j),
        0b110110: (1+1j), 0b110111: (1+3j), 0b110101: (1+5j), 0b110100: (1+7j), 
        0b111000: (3-7j), 0b111001: (3-5j), 0b111011: (3-3j), 0b111010: (3-1j), 
        0b111110: (3+1j), 0b111111: (3+3j), 0b111101: (3+5j), 0b111100: (3+7j),
        0b101000: (5-7j), 0b101001: (5-5j), 0b101011: (5-3j), 0b101010: (5-1j), 
        0b101110: (5+1j), 0b101111: (5+3j), 0b101101: (5+5j), 0b101100: (5+7j), 
        0b100000: (7-7j), 0b100001: (7-5j), 0b100011: (7-3j), 0b100010: (7-1j), 
        0b100110: (7+1j), 0b100111: (7+3j), 0b100101: (7+5j), 0b100100: (7+7j)
        }
    qam64_nbits     = 6
    qam64_kmod      = 1/(42**0.5)
    
    # 16-QAM constellation (802.11-2020 sec 17.3.5.8)
    qam16_c = {
        0b0000: (-3-3j), 0b0001: (-3-1j), 0b0011: (-3+1j), 0b0010: (-3+3j), 
        0b0100: (-1-3j), 0b0101: (-1-1j), 0b0111: (-1+1j), 0b0110: (-1+3j),
        0b1100: (1-3j), 0b1101: (1-1j), 0b1111: (1+1j), 0b1110: (1+3j), 
        0b1000: (3-3j), 0b1001: (3-1j), 0b1011: (3+1j), 0b1010: (3+3j)
        }
    qam16_nbits     = 4
    qam16_kmod      = 1/(10**0.5)
    
    # QPSK constellation (802.11-2020 sec 17.3.5.8)
    qpsk_c  = {0b00: (-1-1j), 0b01: (-1+1j), 0b10: (1-1j), 0b11: (1+1j)}
    qpsk_nbits      = 2
    qpsk_kmod       = 1/(2**0.5)
    
    # BPSK constellation (802.11-2020 sec 17.3.5.8)
    bpsk_c  = {0b0: (-1+0j), 0b1: (1+0j)}
    bpsk_nbits  = 1
    bpsk_kmod   = 1

    def __init__(
            self, 
            mod_type="BPSK", 
            code_rate="1/2", 
            number_scs=48, 
            cp_len=0
        ):
        """
        Constructor method for the 802.11ax PHY layer model.

        Parameters
        ----------
        mod_type : str, optional
            The modulation type to use. The default is "BPSK".
            Options are "BPSK", "QPSK", "16-QAM", "64-QAM", "256-QAM", 
            "1024-QAM".
        code_rate : str, optional
            The code rate to use. The default is "1/2".
            Options are "1/2", "2/3", "3/4".
        number_scs : int, optional
            The number of subcarriers to use in the OFDM signal. 
            The default is 48.
        cp_len : int, optional
            The length of the cyclic prefix to use in the OFDM signal. 
            The default is 0.
        """
         
        self.mod_type = mod_type
        if mod_type == "1024-QAM":
            self.const      = self.qam1024_c
            self.mod_nb     = self.qam1024_nbits
            self.kmod       = self.qam1024_kmod
        elif mod_type == "256-QAM":
            self.const      = self.qam256_c
            self.mod_nb     = self.qam256_nbits
            self.kmod       = self.qam256_kmod
        elif mod_type == "64-QAM":
            self.const      = self.qam64_c
            self.mod_nb     = self.qam64_nbits
            self.kmod       = self.qam64_kmod
        elif mod_type == "16-QAM":
            self.const      = self.qam16_c
            self.mod_nb     = self.qam16_nbits
            self.kmod       = self.qam16_kmod
        elif mod_type == "QPSK":
            self.const      = self.qpsk_c
            self.mod_nb     = self.qpsk_nbits
            self.kmod       = self.qpsk_kmod
        elif mod_type == "BPSK":
            self.const      = self.bpsk_c
            self.mod_nb     = self.bpsk_nbits
            self.kmod       = self.bpsk_kmod
        else:
            raise ValueError(f"Invalid mod_type parameter, got {mod_type}")
          
        self.code_rate = int(code_rate[0])/int(code_rate[2])
        self.gen_poly = np.array([133, 171])  # 1/2 rate generator polynomial
        self.cc_k     = 7 # 1/2 rate conv. coder constraint length

        # number of subcarriers and length of cyclic prefix, for ofdm
        self.n_scs  = number_scs
        self.cp_len = cp_len 
        
    def qam_modulate(self, bits):
        """
        This method modulates a numpy array of bits into complex QAM symbols.

        Parameters
        ----------
        bits : numpy.ndarray
            A 1D numpy array of bits to be modulated. The number of bits must be
            a multiple of the modulation order.

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of complex QAM symbols.
        """
        if np.ndim(bits) != 1:
            raise ValueError(f"Invalid shape of bits: {np.shape(bits)}")
        elif len(bits) % self.mod_nb != 0:
            raise ValueError(
                f"must input a multiple of {self.mod_nb} bits, got {len(bits)}"
            )
        else:
            # arrange bits and use constellation to modulate
            num_bits = len(bits)
            num_symbols = int(num_bits/self.mod_nb)
            bit_matrix = bits.reshape(num_symbols, self.mod_nb)
            exps = 2**np.flip(np.arange(self.mod_nb)).reshape(self.mod_nb,1)
            keys = list((bit_matrix @ exps).ravel().astype(int))
            symbols = np.array(
                [self.const[key]*self.kmod for key in keys]
            ).astype(complex)
            return symbols
        
    def qam_demodulate(self, symbols):
        """
        This method demodulates a numpy array of complex QAM symbols into bits.

        Parameters
        ----------
        symbols : numpy.ndarray
            A 1D numpy array of complex QAM symbols to be demodulated.

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of bits.
        """
        if np.ndim(symbols) != 1:
            raise ValueError(
                "Invalid shape of symbols: {}".format(np.shape(symbols))
            )

        bits = np.zeros(len(symbols)*self.mod_nb).astype(int)
        if self.mod_type == "BPSK":
            syms = np.real(symbols)
            bits[syms >= 0] = 1
        elif self.mod_type == "QPSK":
            syms_r  = np.real(symbols)
            syms_i  = np.imag(symbols)
            third_quadrant = np.logical_and(syms_r < 0, syms_i < 0)
            fourth_quadrant = np.logical_and(syms_r < 0, syms_i >= 0)
            second_quadrant = np.logical_and(syms_r >= 0, syms_i < 0)
            first_quadrant = np.logical_and(syms_r >= 0, syms_i >= 0)
            bits[::2] = np.where(
                np.logical_or(third_quadrant, fourth_quadrant), 0, 1
            )
            bits[1::2] = np.where(
                np.logical_or(third_quadrant, second_quadrant), 0, 1
            )
        elif self.mod_type == "16-QAM":
            syms_r  = np.real(symbols)
            syms_i  = np.imag(symbols)
            c       = np.array([-3, -1, 1, 3])*self.kmod
            for i in range(len(symbols)):
                # real component gives first two bits
                r_id    = np.argmin(np.abs(c - syms_r[i]))
                if r_id == 0: # real closest to -3
                    bits[4*i:4*i+2] = [0,0]
                elif r_id == 1: # real closest to -1
                    bits[4*i:4*i+2] = [0,1]
                elif r_id == 2: # real closest to +1
                    bits[4*i:4*i+2] = [1,1]
                elif r_id == 3: # real closest to +3
                    bits[4*i:4*i+2] = [1,0]
                # imaginary component gives last two bits
                i_id    = np.argmin(np.abs(c - syms_i[i]))
                if i_id == 0: # real closest to -3
                    bits[4*i+2:4*i+4] = [0,0]
                elif i_id == 1: # real closest to -1
                    bits[4*i+2:4*i+4] = [0,1]
                elif i_id == 2: # real closest to +1
                    bits[4*i+2:4*i+4] = [1,1]
                elif i_id == 3: # real closest to +3
                    bits[4*i+2:4*i+4] = [1,0]
        elif self.mod_type == "64-QAM":
            syms_r  = np.real(symbols)
            syms_i  = np.imag(symbols)
            c       = np.array(range(-7,8,2))*self.kmod
            for i in range(len(symbols)):
                # real component gives first three bits
                r_id    = np.argmin(np.abs(c-syms_r[i]))
                if r_id == 0: # real closest to -7
                    bits[6*i:6*i+3] = [0,0,0]
                elif r_id == 1: # real closest to -5
                    bits[6*i:6*i+3] = [0,0,1]
                elif r_id == 2: # real closest to -3
                    bits[6*i:6*i+3] = [0,1,1]
                elif r_id == 3: # real closest to -1
                    bits[6*i:6*i+3] = [0,1,0]
                elif r_id == 4: # real closest to +1
                    bits[6*i:6*i+3] = [1,1,0]
                elif r_id == 5: # real closest to +3
                    bits[6*i:6*i+3] = [1,1,1]
                elif r_id == 6: # real closest to +5
                    bits[6*i:6*i+3] = [1,0,1]
                elif r_id == 7: # real closest to +7
                    bits[6*i:6*i+3] = [1,0,0]
                # imag component gives last three bits
                i_id    = np.argmin(np.abs(c-syms_i[i]))
                if i_id == 0: # real closest to -7
                    bits[6*i+3:6*i+6] = [0,0,0]
                elif i_id == 1: # real closest to -5
                    bits[6*i+3:6*i+6] = [0,0,1]
                elif i_id == 2: # real closest to -3
                    bits[6*i+3:6*i+6] = [0,1,1]
                elif i_id == 3: # real closest to -1
                    bits[6*i+3:6*i+6] = [0,1,0]
                elif i_id == 4: # real closest to +1
                    bits[6*i+3:6*i+6] = [1,1,0]
                elif i_id == 5: # real closest to +3
                    bits[6*i+3:6*i+6] = [1,1,1]
                elif i_id == 6: # real closest to +5
                    bits[6*i+3:6*i+6] = [1,0,1]
                elif i_id == 7: # real closest to +7
                    bits[6*i+3:6*i+6] = [1,0,0]
        elif self.mod_type == "256-QAM":
            syms_r  = np.real(symbols)
            syms_i  = np.imag(symbols)
            c       = np.array(range(-15,16,2))*self.kmod
            for i in range(len(symbols)):
                # real component gives first four bits
                r_id    = np.argmin(np.abs(c-syms_r[i]))
                if r_id == 0: # real closest to -15
                    bits[8*i:8*i+4] = [0,0,0,0]
                elif r_id == 1: # real closest to -13
                    bits[8*i:8*i+4] = [0,0,0,1]
                elif r_id == 2: # real closest to -11
                    bits[8*i:8*i+4] = [0,0,1,1]
                elif r_id == 3: # real closest to -9
                    bits[8*i:8*i+4] = [0,0,1,0]
                elif r_id == 4: # real closest to -7
                    bits[8*i:8*i+4] = [0,1,1,0]
                elif r_id == 5: # real closest to -5
                    bits[8*i:8*i+4] = [0,1,1,1]
                elif r_id == 6: # real closest to -3
                    bits[8*i:8*i+4] = [0,1,0,1]
                elif r_id == 7: # real closest to -1
                    bits[8*i:8*i+4] = [0,1,0,0]
                elif r_id == 8: # real closest to +1
                    bits[8*i:8*i+4] = [1,1,0,0]
                elif r_id == 9: # real closest to +3
                    bits[8*i:8*i+4] = [1,1,0,1]
                elif r_id == 10: # real closest to +5
                    bits[8*i:8*i+4] = [1,1,1,1]
                elif r_id == 11: # real closest to +7
                    bits[8*i:8*i+4] = [1,1,1,0]
                elif r_id == 12: # real closest to +9
                    bits[8*i:8*i+4] = [1,0,1,0]
                elif r_id == 13: # real closest to +11
                    bits[8*i:8*i+4] = [1,0,1,1]
                elif r_id == 14: # real closest to +13
                    bits[8*i:8*i+4] = [1,0,0,1]
                elif r_id == 15: # real closest to +15
                    bits[8*i:8*i+4] = [1,0,0,0]
                # imag component gives last four bits
                i_id    = np.argmin(np.abs(c-syms_i[i]))
                if i_id == 0: # real closest to -15
                    bits[8*i+4:8*i+8] = [0,0,0,0]
                elif i_id == 1: # real closest to -13
                    bits[8*i+4:8*i+8] = [0,0,0,1]
                elif i_id == 2: # real closest to -11
                    bits[8*i+4:8*i+8] = [0,0,1,1]
                elif i_id == 3: # real closest to -9
                    bits[8*i+4:8*i+8] = [0,0,1,0]
                elif i_id == 4: # real closest to -7
                    bits[8*i+4:8*i+8] = [0,1,1,0]
                elif i_id == 5: # real closest to -5
                    bits[8*i+4:8*i+8] = [0,1,1,1]
                elif i_id == 6: # real closest to -3
                    bits[8*i+4:8*i+8] = [0,1,0,1]
                elif i_id == 7: # real closest to -1
                    bits[8*i+4:8*i+8] = [0,1,0,0]
                elif i_id == 8: # real closest to +1
                    bits[8*i+4:8*i+8] = [1,1,0,0]
                elif i_id == 9: # real closest to +3
                    bits[8*i+4:8*i+8] = [1,1,0,1]
                elif i_id == 10: # real closest to +5
                    bits[8*i+4:8*i+8] = [1,1,1,1]
                elif i_id == 11: # real closest to +7
                    bits[8*i+4:8*i+8] = [1,1,1,0]
                elif i_id == 12: # real closest to +9
                    bits[8*i+4:8*i+8] = [1,0,1,0]
                elif i_id == 13: # real closest to +11
                    bits[8*i+4:8*i+8] = [1,0,1,1]
                elif i_id == 14: # real closest to +13
                    bits[8*i+4:8*i+8] = [1,0,0,1]
                elif i_id == 15: # real closest to +15
                    bits[8*i+4:8*i+8] = [1,0,0,0]
        elif self.mod_type == "1024-QAM":
            syms_r  = np.real(symbols)
            syms_i  = np.imag(symbols)
            c       = np.array(range(-31,32,2))*self.kmod
            for i in range(len(symbols)):
                # real component gives first five bits
                r_id    = np.argmin(np.abs(c-syms_r[i]))
                if r_id == 0: 
                    bits[10*i:10*i+5] = [0,0,0,0,0]
                elif r_id == 1: 
                    bits[10*i:10*i+5] = [0,0,0,0,1]
                elif r_id == 2:
                    bits[10*i:10*i+5] = [0,0,0,1,1]
                elif r_id == 3: 
                    bits[10*i:10*i+5] = [0,0,0,1,0]
                elif r_id == 4: 
                    bits[10*i:10*i+5] = [0,0,1,1,0]
                elif r_id == 5: 
                    bits[10*i:10*i+5] = [0,0,1,1,1]
                elif r_id == 6:
                    bits[10*i:10*i+5] = [0,0,1,0,1]
                elif r_id == 7: 
                    bits[10*i:10*i+5] = [0,0,1,0,0]
                elif r_id == 8: 
                    bits[10*i:10*i+5] = [0,1,1,0,0]
                elif r_id == 9:
                    bits[10*i:10*i+5] = [0,1,1,0,1]
                elif r_id == 10: 
                    bits[10*i:10*i+5] = [0,1,1,1,1]
                elif r_id == 11: 
                    bits[10*i:10*i+5] = [0,1,1,1,0]
                elif r_id == 12: 
                    bits[10*i:10*i+5] = [0,1,0,1,0]
                elif r_id == 13: 
                    bits[10*i:10*i+5] = [0,1,0,1,1]
                elif r_id == 14: 
                    bits[10*i:10*i+5] = [0,1,0,0,1]
                elif r_id == 15: 
                    bits[10*i:10*i+5] = [0,1,0,0,0]
                elif r_id == 16: 
                    bits[10*i:10*i+5] = [1,1,0,0,0]
                elif r_id == 17: 
                    bits[10*i:10*i+5] = [1,1,0,0,1]
                elif r_id == 18: 
                    bits[10*i:10*i+5] = [1,1,0,1,1]
                elif r_id == 19: 
                    bits[10*i:10*i+5] = [1,1,0,1,0]
                elif r_id == 20: 
                    bits[10*i:10*i+5] = [1,1,1,1,0]
                elif r_id == 21: 
                    bits[10*i:10*i+5] = [1,1,1,1,1]
                elif r_id == 22: 
                    bits[10*i:10*i+5] = [1,1,1,0,1]
                elif r_id == 23: 
                    bits[10*i:10*i+5] = [1,1,1,0,0]
                elif r_id == 24: 
                    bits[10*i:10*i+5] = [1,0,1,0,0]
                elif r_id == 25: 
                    bits[10*i:10*i+5] = [1,0,1,0,1]
                elif r_id == 26: 
                    bits[10*i:10*i+5] = [1,0,1,1,1]
                elif r_id == 27: 
                    bits[10*i:10*i+5] = [1,0,1,1,0]
                elif r_id == 28:
                    bits[10*i:10*i+5] = [1,0,0,1,0]
                elif r_id == 29:
                    bits[10*i:10*i+5] = [1,0,0,1,1]
                elif r_id == 30: 
                    bits[10*i:10*i+5] = [1,0,0,0,1]
                elif r_id == 31: 
                    bits[10*i:10*i+5] = [1,0,0,0,0]
                # imag component gives last five bits
                i_id    = np.argmin(np.abs(c-syms_i[i]))
                if i_id == 0: 
                    bits[10*i+5:10*i+10] = [0,0,0,0,0]
                elif i_id == 1: 
                    bits[10*i+5:10*i+10] = [0,0,0,0,1]
                elif i_id == 2:
                    bits[10*i+5:10*i+10] = [0,0,0,1,1]
                elif i_id == 3: 
                    bits[10*i+5:10*i+10] = [0,0,0,1,0]
                elif i_id == 4: 
                    bits[10*i+5:10*i+10] = [0,0,1,1,0]
                elif i_id == 5: 
                    bits[10*i+5:10*i+10] = [0,0,1,1,1]
                elif i_id == 6:
                    bits[10*i+5:10*i+10] = [0,0,1,0,1]
                elif i_id == 7: 
                    bits[10*i+5:10*i+10] = [0,0,1,0,0]
                elif i_id == 8: 
                    bits[10*i+5:10*i+10] = [0,1,1,0,0]
                elif i_id == 9:
                    bits[10*i+5:10*i+10] = [0,1,1,0,1]
                elif i_id == 10: 
                    bits[10*i+5:10*i+10] = [0,1,1,1,1]
                elif i_id == 11: 
                    bits[10*i+5:10*i+10] = [0,1,1,1,0]
                elif i_id == 12: 
                    bits[10*i+5:10*i+10] = [0,1,0,1,0]
                elif i_id == 13: 
                    bits[10*i+5:10*i+10] = [0,1,0,1,1]
                elif i_id == 14: 
                    bits[10*i+5:10*i+10] = [0,1,0,0,1]
                elif i_id == 15: 
                    bits[10*i+5:10*i+10] = [0,1,0,0,0]
                elif i_id == 16: 
                    bits[10*i+5:10*i+10] = [1,1,0,0,0]
                elif i_id == 17: 
                    bits[10*i+5:10*i+10] = [1,1,0,0,1]
                elif i_id == 18: 
                    bits[10*i+5:10*i+10] = [1,1,0,1,1]
                elif i_id == 19: 
                    bits[10*i+5:10*i+10] = [1,1,0,1,0]
                elif i_id == 20: 
                    bits[10*i+5:10*i+10] = [1,1,1,1,0]
                elif i_id == 21: 
                    bits[10*i+5:10*i+10] = [1,1,1,1,1]
                elif i_id == 22: 
                    bits[10*i+5:10*i+10] = [1,1,1,0,1]
                elif i_id == 23: 
                    bits[10*i+5:10*i+10] = [1,1,1,0,0]
                elif i_id == 24: 
                    bits[10*i+5:10*i+10] = [1,0,1,0,0]
                elif i_id == 25: 
                    bits[10*i+5:10*i+10] = [1,0,1,0,1]
                elif i_id == 26: 
                    bits[10*i+5:10*i+10] = [1,0,1,1,1]
                elif i_id == 27: 
                    bits[10*i+5:10*i+10] = [1,0,1,1,0]
                elif i_id == 28:
                    bits[10*i+5:10*i+10] = [1,0,0,1,0]
                elif i_id == 29:
                    bits[10*i+5:10*i+10] = [1,0,0,1,1]
                elif i_id == 30: 
                    bits[10*i+5:10*i+10] = [1,0,0,0,1]
                elif i_id == 31: 
                    bits[10*i+5:10*i+10] = [1,0,0,0,0]
        # breakpoint()
        return bits
        
    def conv_encode(self, bits):
        """
        This method performs convolutional encoding on a numpy array of bits.
        The code rate is set by the class attribute self.code_rate.

        Details can be found in 802.11-2020 section 17.3.5.6

        Parameters
        ----------
        bits : numpy.ndarray
            A 1D numpy array of input bits.

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of encoded bits.
        """

        K = len(bits)  # Number of input bits
        N = int(2*K)  # Number of output bits (before puncturing)
        
        # get binary representations of generator polynomials
        gen1    = np.array([
            int(x) for x in format(
                int(str(self.gen_poly[0]), 8), '0{}b'.format(self.cc_k)
            )
        ])
        gen2    = np.array([
            int(x) for x in format(
                int(str(self.gen_poly[1]), 8), '0{}b'.format(self.cc_k)
            )
        ])
    
        # Convolutional encoding using the generator polynomial
        output_bits = np.zeros(N, dtype=int)
        state       = np.zeros(self.cc_k, dtype=int)
        for i in range(K):
            # get next input bit
            state[0]    = bits[i]
            # compute output bits based on generator polynomial
            output_bits[i*2] = np.sum(gen1*state)%2
            output_bits[i*2+1] = np.sum(gen2*state)%2
            # shift values in the register
            state[1:] = state[:-1]

        if self.code_rate == 1/2:
            return output_bits
        elif self.code_rate == 2/3:
            punctured = np.arange(N) % 4 != 3
            return output_bits[punctured]
        elif self.code_rate == 3/4:
            punctured1 = np.arange(N) % 6 != 3
            punctured2 = np.arange(N) % 6 != 4
            return output_bits[punctured1 & punctured2]
        else:
            raise ValueError(f"Invalid code rate: {self.code_rate}")

    def viterbi_decode(self, symbols, tb_depth=None, dec_type="hard"):
        """
        This method performs Viterbi decoding on a numpy array, to recover
        the original bits from a convolutionally encoded signal.

        Parameters
        ----------
        symbols : numpy.ndarray
            If dec_type is "hard", this should be a 1D numpy array of bits.
            If dec_type is "soft", this should be a 1D numpy array of complex
            symbols.
        tb_depth : int, optional
            The traceback depth for the Viterbi decoder.
            Default is 3*constraint length.
        dec_type : str, optional
            The type of decoding to perform. Options are "hard" or "soft".
            Default is "hard".

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of decoded bits.
        """
        if dec_type == 'soft' and self.mod_type == "16-QAM" and \
            self.code_rate != 1/2:
            raise ValueError("Soft decoding for 16-QAM only supported for " + \
                             "code rate 1/2")
        if tb_depth == None:
            tb_depth = 3*self.cc_k

        # if soft decoding with QPSK, unravel real and imag parts
        # need to do this to undo puncturing for 2/3 and 3/4 code rates
        if dec_type == "soft" and self.mod_type == "QPSK":
            real_part = np.real(symbols)
            imag_part = np.imag(symbols)
            symbols = np.zeros(2*len(real_part))
            symbols[::2] = real_part
            symbols[1::2] = imag_part

        # un-puncturing the received bits according to the known pattern
        if self.code_rate == 2/3:
            positions = np.arange(3, len(symbols)+1, 3)
            symbols = np.insert(symbols, positions, -999.999)
        elif self.code_rate == 3/4:
            positions = np.arange(3, len(symbols)+1, 4)
            symbols = np.insert(symbols, positions, -999.999)
            positions = np.arange(3, len(symbols)+1, 5)
            symbols = np.insert(symbols, positions, -999.999)
        elif self.code_rate == 1/2:
            pass
        else:
            raise ValueError(f"Invalid code rate: {self.code_rate}")

        # define trellis structure (from MATLAB's poly2trellis func)
        n_states    = 64
        outputs     = np.array([
            [0,3],[3,0],[2,1],[1,2],[0,3],[3,0],[2,1],[1,2],[3,0],[0,3],
            [1,2],[2,1],[3,0],[0,3],[1,2],[2,1],[3,0],[0,3],[1,2],[2,1],
            [3,0],[0,3],[1,2],[2,1],[0,3],[3,0],[2,1],[1,2],[0,3],[3,0],
            [2,1],[1,2],[1,2],[2,1],[3,0],[0,3],[1,2],[2,1],[3,0],[0,3],
            [2,1],[1,2],[0,3],[3,0],[2,1],[1,2],[0,3],[3,0],[2,1],[1,2],
            [0,3],[3,0],[2,1],[1,2],[0,3],[3,0],[1,2],[2,1],[3,0],[0,3],
            [1,2],[2,1],[3,0],[0,3]
            ]).astype(int)
        bin_outs = np.zeros((128,2)).astype(int)
        for i, output in enumerate(outputs.ravel()):
            bin_outs[i] = [int(x) for x in format(output, '02b')]
        nxt_states  = np.array([
            [0,32],[0,32],[1,33],[1,33],[2,34],[2,34],[3,35],[3,35],
            [4,36],[4,36],[5,37],[5,37],[6,38],[6,38],[7,39],[7,39],
            [8,40],[8,40],[9,41],[9,41],[10,42],[10,42],[11,43],[11,43],
            [12,44],[12,44],[13,45],[13,45],[14,46],[14,46],[15,47],[15,47],
            [16,48],[16,48],[17,49],[17,49],[18,50],[18,50],[19,51],[19,51],
            [20,52],[20,52],[21,53],[21,53],[22,54],[22,54],[23,55],[23,55],
            [24,56],[24,56],[25,57],[25,57],[26,58],[26,58],[27,59],[27,59],
            [28,60],[28,60],[29,61],[29,61],[30,62],[30,62],[31,63],[31,63]
            ])
        # get idx_mat to be used later 
        nxt_states_0in = nxt_states[:,0]
        rep_0in = np.repeat(nxt_states_0in[:,np.newaxis], 32, axis=1)
        idx_mat = rep_0in == np.arange(32)
        
        paths   = np.array(range(n_states)).reshape((n_states,1))
        path_ms = np.zeros((2**(self.cc_k - 1),1))
        
        # if soft decoding, modulation type determines size of the output
        if dec_type == "hard":
            decoded_bits = np.zeros((int(len(symbols)/2),)).astype(int)
        elif self.mod_type == "BPSK":
            decoded_bits = np.zeros((int(len(symbols)/2),)).astype(int)
        elif self.mod_type == "QPSK":
            decoded_bits = np.zeros((int(len(symbols)/2),)).astype(int)
        elif self.mod_type == "16-QAM":
            def op_func(op_arr):
                new_arr = np.zeros(np.shape(op_arr)).astype(int)
                new_arr[op_arr == 0] = -3
                new_arr[op_arr == 1] = -1
                new_arr[op_arr == 2] = 3
                new_arr[op_arr == 3] = 1
                return new_arr
            outputs = op_func(outputs)
            decoded_bits = np.zeros(int(len(symbols)*2),).astype(int)
        else:
            raise NotImplementedError(
                f"soft Viterbi decoding not supported for {self.mod_type}"
            )
            
        b_id = 0
        new_sts = np.array(range(n_states)).reshape((n_states,1))
        path_ms = np.zeros((n_states,1))
        prev_sts = np.zeros((n_states//2,)).astype(int)
        # Loop over input symbols two at a time (since op of conv is size 2)
        for b in range(len(decoded_bits)):
            # Compute branch metrics for current branch
            if dec_type == "hard":
                # for hard decoding, Hamming distance is used
                op = symbols[2*b:2*b+2]
                matches = (op == bin_outs).astype(float)
                # add uncertainty for punctured bits
                if op[0] == -999.999:
                    matches[:,0] = 0.5
                if op[1] == -999.999:
                    matches[:,1] = 0.5
                branch_metrics = np.sum(matches, axis=1).reshape((n_states,2))
            elif dec_type == "soft" and self.mod_type == "BPSK":
                op  = np.real(symbols[2*b:2*b+2])
                # for BPSK soft decoding theory, see pg 250 of Goldsmith
                branch_metrics = op * (2*bin_outs - 1)
                # add uncertainty for punctured bits
                if op[0] == -999.999:
                    branch_metrics[:,0] = 0
                if op[1] == -999.999:
                    branch_metrics[:,1] = 0
                branch_metrics = np.sum(branch_metrics, axis=1)
                branch_metrics = np.reshape(branch_metrics, (n_states,2))
            elif dec_type == "soft" and self.mod_type == "QPSK":
                # op  = np.array([np.real(symbols[b]), np.imag(symbols[b])])
                op = symbols[2*b:2*b+2]
                branch_metrics = op * (2*bin_outs - 1)
                # add uncertainty for punctured bits
                if op[0] == -999.999:
                    branch_metrics[:,0] = 0
                if op[1] == -999.999:
                    branch_metrics[:,1] = 0
                branch_metrics = np.sum(branch_metrics, axis=1)
                branch_metrics = np.reshape(branch_metrics, (n_states,2))
            elif dec_type == "soft" and self.mod_type == "16-QAM":
                # 16-QAM
                # 2 bits from even branches correspond to real part of QAM symbol
                if b % 2 == 0:
                    op = np.real(symbols[int(b/2)])
                    branch_metrics = 2*op*outputs - self.qam16_kmod*np.square(outputs)
                # 2 bits from odd branches correspond to imag part of QAM symbol
                if b % 2 != 0:
                    op = np.imag(symbols[int((b-1)/2)])
                    branch_metrics = 2*op*outputs - self.qam16_kmod*np.square(outputs)
            else:
                raise NotImplementedError(
                    f"soft Viterbi decoding not supported for {self.mod_type}"
                )
            
            # add the current branch metrics to the save path metrics
            br_mets = branch_metrics + path_ms

            # ---- VECTORIZED VERSION OF THE FOR LOOP BELOW ----
            new_paths = np.zeros(np.shape(paths))
            for h in range(2):
                hlf_br_mets = br_mets[:,h].reshape((32,2))
                b0_greater = hlf_br_mets[:,0] > hlf_br_mets[:,1]
                path_ms[h*32:(h+1)*32,:] = np.where(
                    b0_greater, 
                    hlf_br_mets[:,0], 
                    hlf_br_mets[:,1]
                ).reshape((32,1))
                b0s, _ = np.where(idx_mat[:,b0_greater])
                prev_sts[b0_greater] = b0s[0::2]
                b1s, _ = np.where(idx_mat[:,~b0_greater])
                prev_sts[~b0_greater] = b1s[1::2]
                new_paths[h*32:(h+1)*32,:] = paths[prev_sts,:]
            # ---------------------------------------------------

            # # ---- LEGACY CODE: MORE READABLE VERSION OF THE ABOVE ----  
            # # iterate over destination states to update paths
            # # path correspond to the DESTINATION node, e.g. path 0 is
            # # the path terminating in node 0, and so on
            # # nodes in a path are listed in reverse order
            # # old_paths   = paths.copy()
            # # old_path_ms = path_ms.copy()
            # new_paths   = np.zeros(np.shape(paths))
            # for j in range(n_states):
            #     # can split this part in two due to trellis structure
            #     if j < 32:
            #         idxs        = (nxt_states[:,0] == j) 
            #         mets        = br_mets[idxs][:,0]
            #         if mets[0] > mets[1]:
            #             mx_met  = mets[0]
            #             prev_st = np.where(idxs)[0][0]
            #         else:
            #             mx_met = mets[1]
            #             prev_st = np.where(idxs)[0][1]
            #     else:
            #         idxs        = (nxt_states[:,1] == j) 
            #         mets        = br_mets[idxs][:,1]
            #         if mets[0] > mets[1]:
            #             mx_met  = mets[0]
            #             prev_st = np.where(idxs)[0][0]
            #         else:
            #             mx_met = mets[1]
            #             prev_st = np.where(idxs)[0][1]

            #     # get old path terminating in prev_st, will connect after
            #     new_paths[j,:]  = paths[prev_st,:]
                
            #     # update the path metric corresponding for the current next state
            #     path_ms[j] = mx_met
            # ---------------------------------------------------------
            
            # add next states to old paths
            paths   = np.append(new_sts, new_paths, axis=1)
                
            # check to see if any branches can be clipped
            n = len(paths[0])
            while True:
                # if first branch of all paths is the same
                if (paths[:,n-2:n] == paths[0,n-2:n]).all():
                    # decide on bit
                    src_st  = int(paths[0,n-1])
                    tgt_st  = int(paths[0,n-2])
                    decoded_bits[b_id] = int(np.where(nxt_states[src_st] == tgt_st)[0])
                    b_id += 1
                    # clip branch by removing souce nodes
                    paths = paths[:,:-1]
                    # update length of the paths
                    n = n - 1
                    # if we have clipped all the way to one node, break
                    if n == 1:
                        break
                # if we find a split at a node, break out of loop
                else:
                    break
            
            # if the path length is longer than the traceback depth,
            # decode root based on max metric and clip branch
            if len(paths[0,:]) > tb_depth:
                n = len(paths[0,:])
                max_path = paths[np.argmax(path_ms),:]
                src_st  = int(max_path[n-1])
                tgt_st  = int(max_path[n-2])
                decoded_bits[b_id] = int(np.where(nxt_states[src_st] == tgt_st)[0])
                b_id += 1
                paths = paths[:,:-1]

        # once we have iterated through all coded bits, takes highest 
        # metric path and use it to decode the rest
        max_path     = paths[np.argmax(path_ms),:]
        for n in range(len(max_path),1,-1):
            src_st  = int(max_path[n-1])
            tgt_st  = int(max_path[n-2])
            decoded_bits[b_id] = int(np.where(nxt_states[src_st] == tgt_st)[0])
            b_id += 1
            
        return decoded_bits
    
    def ofdm_modulate(self, symbols):
        """
        This method performs OFDM modulation on a numpy array of
        complex QAM symbols. The number of subcarriers and cyclic prefix length
        are set by the class attributes self.n_scs and self.cp_len.

        Parameters
        ----------
        symbols : numpy.ndarray
            A 1D numpy array of complex QAM symbols.

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of complex time-domain symbols.
        """
        num_scs     = self.n_scs
        cp_len      = self.cp_len
        if np.ndim(symbols) != 1:
            raise ValueError(f"Invalid shape of symbols: {np.shape(symbols)}")
        elif len(symbols) % num_scs != 0:
            raise ValueError(
                f"Input must be multiple of {num_scs}, got {len(symbols)}"
            )
        
        # serial to parallel conversion
        freq_mat = symbols.reshape((num_scs,int(len(symbols)/num_scs)))
        fr_shp = np.shape(freq_mat)
        # get IFFT of the parallel symbols and add cyclic prefix
        time_mat = np.zeros((fr_shp[0]+cp_len, fr_shp[1])).astype(complex)
        tm_shp = np.shape(time_mat)
        for i in range(np.shape(freq_mat)[1]):
            time_mat[cp_len:,i] = np.fft.ifft(freq_mat[:,i])*np.sqrt(num_scs)
            if cp_len != 0:
                time_mat[:cp_len,i] = time_mat[-cp_len:,i]
        # parallel to serial conversion
        time_seq    = time_mat.reshape((tm_shp[0]*tm_shp[1],))
        return time_seq
        
    def ofdm_demodulate(self, symbols):
        """
        This method performs OFDM demodulation on a numpy array of
        complex time-domain symbols. The number of subcarriers and cyclic prefix
        length are set by the class attributes self.n_scs and self.cp_len.

        Parameters
        ----------
        symbols : numpy.ndarray
            A 1D numpy array of complex time-domain symbols.

        Returns
        -------
        numpy.ndarray
            A 1D numpy array of complex QAM symbols.
        """
        num_scs     = self.n_scs
        cp_len      = self.cp_len
        if np.ndim(symbols) != 1:
            raise ValueError(f"Invalid shape of symbols: {symbols.shape}")
        # serial to parallel conversion
        time_mat = symbols.reshape((num_scs+cp_len,int(len(symbols)/(num_scs+cp_len))))
        freq_mat = np.zeros((num_scs,int(len(symbols)/(num_scs+cp_len)))).astype(complex)
        fr_shp = np.shape(freq_mat)
        # remove cyclic prefix and convert back to QAM symbols
        for i in range(np.shape(time_mat)[1]):
            freq_mat[:,i] = np.fft.fft(time_mat[cp_len:,i])/np.sqrt(num_scs)
        # parallel to serial conversion
        qam_seq     = freq_mat.reshape((fr_shp[0]*fr_shp[1],))
        return qam_seq
    
# ------------------------------------------------------------------------------


            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            